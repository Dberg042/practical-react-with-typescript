//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IAppControllerClient {
	getHealth(): Promise<void>
}

export class AppControllerClient implements IAppControllerClient {
	private http: {
		fetch(url: RequestInfo, init?: RequestInit): Promise<Response>
	}
	private baseUrl: string
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
		undefined

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
	) {
		this.http = http ? http : (window as any)
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
	}

	getHealth(): Promise<void> {
		let url_ = this.baseUrl + "/health"
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "GET",
			headers: {}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetHealth(_response)
		})
	}

	protected processGetHealth(response: Response): Promise<void> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<void>(null as any)
	}
}

export interface IUsersControllerClient {
	getUser(id: string): Promise<UserDTO>

	/**
	 * @return The deleted user
	 */
	deleteUser(id: string): Promise<UserDTO>

	/**
	 * @return The user
	 */
	getUsers(): Promise<UserDTO[]>

	/**
	 * @return The newly created user
	 */
	createUser(body: UserWithoutIDDTO): Promise<UserDTO>

	/**
	 * @return The updated user
	 */
	updateUser(body: UserDTO): Promise<UserDTO>

	/**
	 * @return All memberships for the current user
	 */
	getUserMemberships(id: string): Promise<string[]>

	/**
	 * @return The new memberships for the user
	 */
	setUserMemberships(id: string, body: string[]): Promise<UserMembershipsDTO>
}

export class UsersControllerClient implements IUsersControllerClient {
	private http: {
		fetch(url: RequestInfo, init?: RequestInit): Promise<Response>
	}
	private baseUrl: string
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
		undefined

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
	) {
		this.http = http ? http : (window as any)
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
	}

	getUser(id: string): Promise<UserDTO> {
		let url_ = this.baseUrl + "/users/{id}"
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.")
		url_ = url_.replace("{id}", encodeURIComponent("" + id))
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUser(_response)
		})
	}

	protected processGetUser(response: Response): Promise<UserDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = UserDTO.fromJS(resultData200)
				return result200
			})
		} else if (status === 404) {
			return response.text().then((_responseText) => {
				return throwException(
					"No user with this ID exists",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<UserDTO>(null as any)
	}

	/**
	 * @return The deleted user
	 */
	deleteUser(id: string): Promise<UserDTO> {
		let url_ = this.baseUrl + "/users/{id}"
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.")
		url_ = url_.replace("{id}", encodeURIComponent("" + id))
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "DELETE",
			headers: {
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteUser(_response)
		})
	}

	protected processDeleteUser(response: Response): Promise<UserDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = UserDTO.fromJS(resultData200)
				return result200
			})
		} else if (status === 404) {
			return response.text().then((_responseText) => {
				return throwException(
					"No user with the given id exists",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<UserDTO>(null as any)
	}

	/**
	 * @return The user
	 */
	getUsers(): Promise<UserDTO[]> {
		let url_ = this.baseUrl + "/users"
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUsers(_response)
		})
	}

	protected processGetUsers(response: Response): Promise<UserDTO[]> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				if (Array.isArray(resultData200)) {
					result200 = [] as any
					for (let item of resultData200) result200!.push(UserDTO.fromJS(item))
				} else {
					result200 = <any>null
				}
				return result200
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<UserDTO[]>(null as any)
	}

	/**
	 * @return The newly created user
	 */
	createUser(body: UserWithoutIDDTO): Promise<UserDTO> {
		let url_ = this.baseUrl + "/users"
		url_ = url_.replace(/[?&]$/, "")

		const content_ = JSON.stringify(body)

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCreateUser(_response)
		})
	}

	protected processCreateUser(response: Response): Promise<UserDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 201) {
			return response.text().then((_responseText) => {
				let result201: any = null
				let resultData201 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result201 = UserDTO.fromJS(resultData201)
				return result201
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<UserDTO>(null as any)
	}

	/**
	 * @return The updated user
	 */
	updateUser(body: UserDTO): Promise<UserDTO> {
		let url_ = this.baseUrl + "/users"
		url_ = url_.replace(/[?&]$/, "")

		const content_ = JSON.stringify(body)

		let options_: RequestInit = {
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processUpdateUser(_response)
		})
	}

	protected processUpdateUser(response: Response): Promise<UserDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = UserDTO.fromJS(resultData200)
				return result200
			})
		} else if (status === 404) {
			return response.text().then((_responseText) => {
				return throwException(
					"No user with the given ID exists",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<UserDTO>(null as any)
	}

	/**
	 * @return All memberships for the current user
	 */
	getUserMemberships(id: string): Promise<string[]> {
		let url_ = this.baseUrl + "/users/{id}/memberships"
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.")
		url_ = url_.replace("{id}", encodeURIComponent("" + id))
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUserMemberships(_response)
		})
	}

	protected processGetUserMemberships(response: Response): Promise<string[]> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				if (Array.isArray(resultData200)) {
					result200 = [] as any
					for (let item of resultData200) result200!.push(item)
				} else {
					result200 = <any>null
				}
				return result200
			})
		} else if (status === 404) {
			return response.text().then((_responseText) => {
				return throwException(
					"No user exists with the specified id",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<string[]>(null as any)
	}

	/**
	 * @return The new memberships for the user
	 */
	setUserMemberships(id: string, body: string[]): Promise<UserMembershipsDTO> {
		let url_ = this.baseUrl + "/users/{id}/memberships"
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.")
		url_ = url_.replace("{id}", encodeURIComponent("" + id))
		url_ = url_.replace(/[?&]$/, "")

		const content_ = JSON.stringify(body)

		let options_: RequestInit = {
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processSetUserMemberships(_response)
		})
	}

	protected processSetUserMemberships(
		response: Response
	): Promise<UserMembershipsDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = UserMembershipsDTO.fromJS(resultData200)
				return result200
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<UserMembershipsDTO>(null as any)
	}
}

export interface IGroupsControllerClient {
	getGroup(id: string): Promise<GroupDTO>

	/**
	 * @return The deleted group
	 */
	deleteGroup(id: string): Promise<GroupDTO>

	/**
	 * @return All groups
	 */
	getGroups(): Promise<GroupDTO[]>

	/**
	 * @return The newly created group
	 */
	createGroup(body: GroupWithoutIDDTO): Promise<GroupDTO>

	/**
	 * @return The updated group
	 */
	updateGroup(body: GroupDTO): Promise<GroupDTO>

	/**
	 * @return User ids for all members of the group.
	 */
	getMembers(id: string): Promise<string[]>

	/**
	 * @return The new members of the group
	 */
	setMembers(id: string, body: string[]): Promise<GroupMembershipsDTO>
}

export class GroupsControllerClient implements IGroupsControllerClient {
	private http: {
		fetch(url: RequestInfo, init?: RequestInit): Promise<Response>
	}
	private baseUrl: string
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
		undefined

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
	) {
		this.http = http ? http : (window as any)
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
	}

	getGroup(id: string): Promise<GroupDTO> {
		let url_ = this.baseUrl + "/groups/{id}"
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.")
		url_ = url_.replace("{id}", encodeURIComponent("" + id))
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetGroup(_response)
		})
	}

	protected processGetGroup(response: Response): Promise<GroupDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = GroupDTO.fromJS(resultData200)
				return result200
			})
		} else if (status === 404) {
			return response.text().then((_responseText) => {
				return throwException(
					"No group with this ID exists",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<GroupDTO>(null as any)
	}

	/**
	 * @return The deleted group
	 */
	deleteGroup(id: string): Promise<GroupDTO> {
		let url_ = this.baseUrl + "/groups/{id}"
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.")
		url_ = url_.replace("{id}", encodeURIComponent("" + id))
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "DELETE",
			headers: {
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteGroup(_response)
		})
	}

	protected processDeleteGroup(response: Response): Promise<GroupDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = GroupDTO.fromJS(resultData200)
				return result200
			})
		} else if (status === 404) {
			return response.text().then((_responseText) => {
				return throwException(
					"No group with the given id exists",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<GroupDTO>(null as any)
	}

	/**
	 * @return All groups
	 */
	getGroups(): Promise<GroupDTO[]> {
		let url_ = this.baseUrl + "/groups"
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetGroups(_response)
		})
	}

	protected processGetGroups(response: Response): Promise<GroupDTO[]> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				if (Array.isArray(resultData200)) {
					result200 = [] as any
					for (let item of resultData200) result200!.push(GroupDTO.fromJS(item))
				} else {
					result200 = <any>null
				}
				return result200
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<GroupDTO[]>(null as any)
	}

	/**
	 * @return The newly created group
	 */
	createGroup(body: GroupWithoutIDDTO): Promise<GroupDTO> {
		let url_ = this.baseUrl + "/groups"
		url_ = url_.replace(/[?&]$/, "")

		const content_ = JSON.stringify(body)

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCreateGroup(_response)
		})
	}

	protected processCreateGroup(response: Response): Promise<GroupDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 201) {
			return response.text().then((_responseText) => {
				let result201: any = null
				let resultData201 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result201 = GroupDTO.fromJS(resultData201)
				return result201
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<GroupDTO>(null as any)
	}

	/**
	 * @return The updated group
	 */
	updateGroup(body: GroupDTO): Promise<GroupDTO> {
		let url_ = this.baseUrl + "/groups"
		url_ = url_.replace(/[?&]$/, "")

		const content_ = JSON.stringify(body)

		let options_: RequestInit = {
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processUpdateGroup(_response)
		})
	}

	protected processUpdateGroup(response: Response): Promise<GroupDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = GroupDTO.fromJS(resultData200)
				return result200
			})
		} else if (status === 404) {
			return response.text().then((_responseText) => {
				return throwException(
					"No group with the given ID exists",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<GroupDTO>(null as any)
	}

	/**
	 * @return User ids for all members of the group.
	 */
	getMembers(id: string): Promise<string[]> {
		let url_ = this.baseUrl + "/groups/{id}/members"
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.")
		url_ = url_.replace("{id}", encodeURIComponent("" + id))
		url_ = url_.replace(/[?&]$/, "")

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetMembers(_response)
		})
	}

	protected processGetMembers(response: Response): Promise<string[]> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				if (Array.isArray(resultData200)) {
					result200 = [] as any
					for (let item of resultData200) result200!.push(item)
				} else {
					result200 = <any>null
				}
				return result200
			})
		} else if (status === 404) {
			return response.text().then((_responseText) => {
				return throwException(
					"No group exists with the specified id.",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<string[]>(null as any)
	}

	/**
	 * @return The new members of the group
	 */
	setMembers(id: string, body: string[]): Promise<GroupMembershipsDTO> {
		let url_ = this.baseUrl + "/groups/{id}/members"
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.")
		url_ = url_.replace("{id}", encodeURIComponent("" + id))
		url_ = url_.replace(/[?&]$/, "")

		const content_ = JSON.stringify(body)

		let options_: RequestInit = {
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processSetMembers(_response)
		})
	}

	protected processSetMembers(
		response: Response
	): Promise<GroupMembershipsDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = GroupMembershipsDTO.fromJS(resultData200)
				return result200
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<GroupMembershipsDTO>(null as any)
	}
}

export interface IAuthControllerClient {
	/**
	 * @return The userName and password to attempt to log in
	 */
	auth(body: AuthDTO): Promise<AuthResponseDTO>
}

export class AuthControllerClient implements IAuthControllerClient {
	private http: {
		fetch(url: RequestInfo, init?: RequestInit): Promise<Response>
	}
	private baseUrl: string
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
		undefined

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
	) {
		this.http = http ? http : (window as any)
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
	}

	/**
	 * @return The userName and password to attempt to log in
	 */
	auth(body: AuthDTO): Promise<AuthResponseDTO> {
		let url_ = this.baseUrl + "/auth"
		url_ = url_.replace(/[?&]$/, "")

		const content_ = JSON.stringify(body)

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		}

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processAuth(_response)
		})
	}

	protected processAuth(response: Response): Promise<AuthResponseDTO> {
		const status = response.status
		let _headers: any = {}
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v))
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver)
				result200 = AuthResponseDTO.fromJS(resultData200)
				return result200
			})
		} else if (status === 401) {
			return response.text().then((_responseText) => {
				return throwException(
					"UserName or password incorrect",
					status,
					_responseText,
					_headers
				)
			})
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				)
			})
		}
		return Promise.resolve<AuthResponseDTO>(null as any)
	}
}

export class UserDTO implements IUserDTO {
	id!: string
	userName!: string
	/** A password between 6-64 characters */
	password!: string
	firstName?: string
	lastName?: string
	email?: string
	age?: number
	comments?: string
	disabled?: boolean
	disabledSince?: string;

	[key: string]: any

	constructor(data?: IUserDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.id = _data["id"]
			this.userName = _data["userName"]
			this.password = _data["password"]
			this.firstName = _data["firstName"]
			this.lastName = _data["lastName"]
			this.email = _data["email"]
			this.age = _data["age"]
			this.comments = _data["comments"]
			this.disabled = _data["disabled"]
			this.disabledSince = _data["disabledSince"]
		}
	}

	static fromJS(data: any): UserDTO {
		data = typeof data === "object" ? data : {}
		let result = new UserDTO()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["id"] = this.id
		data["userName"] = this.userName
		data["password"] = this.password
		data["firstName"] = this.firstName
		data["lastName"] = this.lastName
		data["email"] = this.email
		data["age"] = this.age
		data["comments"] = this.comments
		data["disabled"] = this.disabled
		data["disabledSince"] = this.disabledSince
		return data
	}
}

export interface IUserDTO {
	id: string
	userName: string
	/** A password between 6-64 characters */
	password: string
	firstName?: string
	lastName?: string
	email?: string
	age?: number
	comments?: string
	disabled?: boolean
	disabledSince?: string

	[key: string]: any
}

export class UserWithoutIDDTO implements IUserWithoutIDDTO {
	userName!: string
	/** A password between 6-64 characters */
	password!: string
	firstName?: string
	lastName?: string
	email?: string
	age?: number
	comments?: string
	disabled?: boolean
	disabledSince?: string;

	[key: string]: any

	constructor(data?: IUserWithoutIDDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.userName = _data["userName"]
			this.password = _data["password"]
			this.firstName = _data["firstName"]
			this.lastName = _data["lastName"]
			this.email = _data["email"]
			this.age = _data["age"]
			this.comments = _data["comments"]
			this.disabled = _data["disabled"]
			this.disabledSince = _data["disabledSince"]
		}
	}

	static fromJS(data: any): UserWithoutIDDTO {
		data = typeof data === "object" ? data : {}
		let result = new UserWithoutIDDTO()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["userName"] = this.userName
		data["password"] = this.password
		data["firstName"] = this.firstName
		data["lastName"] = this.lastName
		data["email"] = this.email
		data["age"] = this.age
		data["comments"] = this.comments
		data["disabled"] = this.disabled
		data["disabledSince"] = this.disabledSince
		return data
	}
}

export interface IUserWithoutIDDTO {
	userName: string
	/** A password between 6-64 characters */
	password: string
	firstName?: string
	lastName?: string
	email?: string
	age?: number
	comments?: string
	disabled?: boolean
	disabledSince?: string

	[key: string]: any
}

export class UserMembershipsDTO implements IUserMembershipsDTO {
	user!: User
	/** Group ids of groups this user is a member of */
	memberOfIds!: string[];

	[key: string]: any

	constructor(data?: IUserMembershipsDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
		if (!data) {
			this.user = new User()
			this.memberOfIds = []
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.user = _data["user"] ? User.fromJS(_data["user"]) : new User()
			if (Array.isArray(_data["memberOfIds"])) {
				this.memberOfIds = [] as any
				for (let item of _data["memberOfIds"]) this.memberOfIds!.push(item)
			}
		}
	}

	static fromJS(data: any): UserMembershipsDTO {
		data = typeof data === "object" ? data : {}
		let result = new UserMembershipsDTO()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["user"] = this.user ? this.user.toJSON() : <any>undefined
		if (Array.isArray(this.memberOfIds)) {
			data["memberOfIds"] = []
			for (let item of this.memberOfIds) data["memberOfIds"].push(item)
		}
		return data
	}
}

export interface IUserMembershipsDTO {
	user: User
	/** Group ids of groups this user is a member of */
	memberOfIds: string[]

	[key: string]: any
}

export class GroupDTO implements IGroupDTO {
	id!: string
	name!: string
	role!: GroupDTORole
	description?: string;

	[key: string]: any

	constructor(data?: IGroupDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.id = _data["id"]
			this.name = _data["name"]
			this.role = _data["role"]
			this.description = _data["description"]
		}
	}

	static fromJS(data: any): GroupDTO {
		data = typeof data === "object" ? data : {}
		let result = new GroupDTO()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["id"] = this.id
		data["name"] = this.name
		data["role"] = this.role
		data["description"] = this.description
		return data
	}
}

export interface IGroupDTO {
	id: string
	name: string
	role: GroupDTORole
	description?: string

	[key: string]: any
}

export class GroupWithoutIDDTO implements IGroupWithoutIDDTO {
	name!: string
	role!: GroupWithoutIDDTORole
	description?: string;

	[key: string]: any

	constructor(data?: IGroupWithoutIDDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.name = _data["name"]
			this.role = _data["role"]
			this.description = _data["description"]
		}
	}

	static fromJS(data: any): GroupWithoutIDDTO {
		data = typeof data === "object" ? data : {}
		let result = new GroupWithoutIDDTO()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["name"] = this.name
		data["role"] = this.role
		data["description"] = this.description
		return data
	}
}

export interface IGroupWithoutIDDTO {
	name: string
	role: GroupWithoutIDDTORole
	description?: string

	[key: string]: any
}

export class GroupMembershipsDTO implements IGroupMembershipsDTO {
	group!: Group
	/** User ids of users that are members of this group. */
	memberIds!: string[];

	[key: string]: any

	constructor(data?: IGroupMembershipsDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
		if (!data) {
			this.group = new Group()
			this.memberIds = []
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.group = _data["group"] ? Group.fromJS(_data["group"]) : new Group()
			if (Array.isArray(_data["memberIds"])) {
				this.memberIds = [] as any
				for (let item of _data["memberIds"]) this.memberIds!.push(item)
			}
		}
	}

	static fromJS(data: any): GroupMembershipsDTO {
		data = typeof data === "object" ? data : {}
		let result = new GroupMembershipsDTO()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["group"] = this.group ? this.group.toJSON() : <any>undefined
		if (Array.isArray(this.memberIds)) {
			data["memberIds"] = []
			for (let item of this.memberIds) data["memberIds"].push(item)
		}
		return data
	}
}

export interface IGroupMembershipsDTO {
	group: Group
	/** User ids of users that are members of this group. */
	memberIds: string[]

	[key: string]: any
}

export class AuthDTO implements IAuthDTO {
	userName!: string
	password!: string;

	[key: string]: any

	constructor(data?: IAuthDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.userName = _data["userName"]
			this.password = _data["password"]
		}
	}

	static fromJS(data: any): AuthDTO {
		data = typeof data === "object" ? data : {}
		let result = new AuthDTO()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["userName"] = this.userName
		data["password"] = this.password
		return data
	}
}

export interface IAuthDTO {
	userName: string
	password: string

	[key: string]: any
}

export class AuthResponseDTO implements IAuthResponseDTO {
	id!: string
	userName!: string
	authenticated!: boolean;

	[key: string]: any

	constructor(data?: IAuthResponseDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.id = _data["id"]
			this.userName = _data["userName"]
			this.authenticated = _data["authenticated"]
		}
	}

	static fromJS(data: any): AuthResponseDTO {
		data = typeof data === "object" ? data : {}
		let result = new AuthResponseDTO()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["id"] = this.id
		data["userName"] = this.userName
		data["authenticated"] = this.authenticated
		return data
	}
}

export interface IAuthResponseDTO {
	id: string
	userName: string
	authenticated: boolean

	[key: string]: any
}

export class User implements IUser {
	id!: string
	userName!: string
	/** A password between 6-64 characters */
	password!: string
	firstName?: string
	lastName?: string
	email?: string
	age?: number
	comments?: string
	disabled?: boolean
	disabledSince?: string;

	[key: string]: any

	constructor(data?: IUser) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.id = _data["id"]
			this.userName = _data["userName"]
			this.password = _data["password"]
			this.firstName = _data["firstName"]
			this.lastName = _data["lastName"]
			this.email = _data["email"]
			this.age = _data["age"]
			this.comments = _data["comments"]
			this.disabled = _data["disabled"]
			this.disabledSince = _data["disabledSince"]
		}
	}

	static fromJS(data: any): User {
		data = typeof data === "object" ? data : {}
		let result = new User()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["id"] = this.id
		data["userName"] = this.userName
		data["password"] = this.password
		data["firstName"] = this.firstName
		data["lastName"] = this.lastName
		data["email"] = this.email
		data["age"] = this.age
		data["comments"] = this.comments
		data["disabled"] = this.disabled
		data["disabledSince"] = this.disabledSince
		return data
	}
}

export interface IUser {
	id: string
	userName: string
	/** A password between 6-64 characters */
	password: string
	firstName?: string
	lastName?: string
	email?: string
	age?: number
	comments?: string
	disabled?: boolean
	disabledSince?: string

	[key: string]: any
}

export enum GroupDTORole {
	Guest = "guest",
	User = "user",
	UserAdmin = "userAdmin",
	GroupAdmin = "groupAdmin"
}

export enum GroupWithoutIDDTORole {
	Guest = "guest",
	User = "user",
	UserAdmin = "userAdmin",
	GroupAdmin = "groupAdmin"
}

export class Group implements IGroup {
	id!: string
	name!: string
	role!: GroupRole
	description?: string;

	[key: string]: any

	constructor(data?: IGroup) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property]
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			for (var property in _data) {
				if (_data.hasOwnProperty(property)) this[property] = _data[property]
			}
			this.id = _data["id"]
			this.name = _data["name"]
			this.role = _data["role"]
			this.description = _data["description"]
		}
	}

	static fromJS(data: any): Group {
		data = typeof data === "object" ? data : {}
		let result = new Group()
		result.init(data)
		return result
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {}
		for (var property in this) {
			if (this.hasOwnProperty(property)) data[property] = this[property]
		}
		data["id"] = this.id
		data["name"] = this.name
		data["role"] = this.role
		data["description"] = this.description
		return data
	}
}

export interface IGroup {
	id: string
	name: string
	role: GroupRole
	description?: string

	[key: string]: any
}

export enum GroupRole {
	Guest = "guest",
	User = "user",
	UserAdmin = "userAdmin",
	GroupAdmin = "groupAdmin"
}

export class ApiException extends Error {
	override message: string
	status: number
	response: string
	headers: { [key: string]: any }
	result: any

	constructor(
		message: string,
		status: number,
		response: string,
		headers: { [key: string]: any },
		result: any
	) {
		super()

		this.message = message
		this.status = status
		this.response = response
		this.headers = headers
		this.result = result
	}

	protected isApiException = true

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: { [key: string]: any },
	result?: any
): any {
	if (result !== null && result !== undefined) throw result
	else throw new ApiException(message, status, response, headers, null)
}
